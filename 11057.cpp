#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

const int mod_num = 10007;

int main() {
    int case_num;
    cin >> case_num;

    vector<vector<int>> dp(1001, vector<int>(10, 0));

    for (int k = 0; k <= 9; k++) {
        dp[1][k] = 1;
    }

    for (int i = 2; i <= case_num; i++) {
        for (int j = 0; j <= 9; j++) {
            if (j == 0)
                dp[i][j] = dp[i - 1][j];
            else
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod_num;
        }
    }

    int result = 0;
    for (int i = 0; i <= 9; i++) {
        result = (result + dp[case_num][i]) % mod_num;
    }

    cout << result << endl;
    return 0;
}

//오르막 수 : 수의 자리가 오름차순을 이루는 수 (인접한 수가 같아도 오름차순으로 인정)
//ex) 2234 와 3678, 11119 는 오르막 수, 2232, 3676, 91111는 아님
//입력 : 수의 길이 n이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램 작성 (수는 0으로 시작할 수 있음)
//출력 : 오르막 수의 개수

//예제1: 1 -> 10 (1 1 1 1 1 1 1 1 1) 5 * 4 / 2
//예제2: 2 -> 11 * 10 / 2 = 55 (1 2 3 4 5 6 7 8 9 10)
//예제3 : 3 -> 10 (1 3 6 10 15 21 28 36 45 55)

//조합을 생각해보자
//dp[][] 벡터가 있을 때, 앞에 들어가는 []는 오르막 수의 길이를 나타내는 것
//뒤에 들어가는 []는 오르막 수의 처음에 시작하는 수를 나타내는 것이다
//조건을 맞추려면 처음 들어간 수 다음으로 들어가는 수들은 그전 수보다 크거나 같아야 함
//예를 들어 길이가 2인 오르막 수의 처음이 2라면 다음 수는 3,4,5,6,7,8,9 만 가능하다
//이를 점화식으로 나타내려면, 먼저 초기 설정을 해줘야 한다.
//dp[1] 길이가 1일 때, dp[1][0] = 1 dp[1][1] - 1 .... dp[1][9] = 1이다
//dp[2] 길이가 2일 때, dp[2][0] = 0보다 같거나 큰 모든 수가 들어갈 수 있음으로 10
//dp[2][1] = 1보다 크거나 같은 수가 가능하므로 9 ... 이런식으로 진행된다
//이를 점화식으로 정리하면 dp[n][i] = dp[n][i - 1] + dp[n - 1][i]